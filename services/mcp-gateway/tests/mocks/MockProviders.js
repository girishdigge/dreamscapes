// tests/mocks/MockProviders.js
// Mock providers for isolated testing

class MockBaseProvider {
  constructor(name, config = {}) {
    this.name = name;
    this.config = {
      enabled: true,
      priority: 1,
      maxConcurrent: 5,
      timeout: 30000,
      ...config,
    };
    this.isHealthy = true;
    this.responseDelay = config.responseDelay || 100;
    this.shouldFail = config.shouldFail || false;
    this.failureRate = config.failureRate || 0;
    this.requestCount = 0;
    this.successCount = 0;
    this.failureCount = 0;
    this.totalResponseTime = 0;
  }

  async generateDream(prompt, options = {}) {
    this.requestCount++;
    const startTime = Date.now();

    // Simulate response delay
    await new Promise((resolve) => setTimeout(resolve, this.responseDelay));

    // Simulate random failures based on failure rate
    const shouldFailThisRequest =
      this.shouldFail || Math.random() < this.failureRate;

    if (shouldFailThisRequest) {
      this.failureCount++;
      throw new Error(`${this.name} provider failure`);
    }

    this.successCount++;
    const responseTime = Date.now() - startTime;
    this.totalResponseTime += responseTime;

    return {
      success: true,
      data: {
        title: `Mock ${this.name} Dream`,
        description: `A dream generated by mock ${this.name} provider`,
        scenes: [
          {
            type: 'environment',
            description: `Mock scene from ${this.name}`,
            mood: 'test',
            lighting: 'mock lighting',
            objects: [
              {
                type: 'test-object',
                position: { x: 0, y: 0, z: 0 },
                properties: { provider: this.name },
              },
            ],
          },
        ],
        style: options.style || 'ethereal',
      },
      metadata: {
        source: this.name,
        model: `mock-${this.name}-model`,
        processingTime: responseTime,
        confidence: 0.85,
        tokens: {
          input: Math.ceil(prompt.length / 4),
          output: 200,
          total: Math.ceil(prompt.length / 4) + 200,
        },
      },
    };
  }

  async testConnection() {
    // Simulate response delay
    await new Promise((resolve) => setTimeout(resolve, this.responseDelay));

    if (!this.isHealthy) {
      throw new Error(`${this.name} connection test failed`);
    }

    return {
      status: 'healthy',
      latency: this.responseDelay,
      timestamp: Date.now(),
    };
  }

  getMetrics() {
    return {
      totalRequests: this.requestCount,
      successfulRequests: this.successCount,
      failedRequests: this.failureCount,
      successRate:
        this.requestCount > 0 ? this.successCount / this.requestCount : 0,
      averageResponseTime:
        this.successCount > 0 ? this.totalResponseTime / this.successCount : 0,
      isHealthy: this.isHealthy,
    };
  }

  setHealthy(healthy) {
    this.isHealthy = healthy;
  }

  setFailureRate(rate) {
    this.failureRate = Math.max(0, Math.min(1, rate));
  }

  setResponseDelay(delay) {
    this.responseDelay = Math.max(0, delay);
  }

  reset() {
    this.requestCount = 0;
    this.successCount = 0;
    this.failureCount = 0;
    this.totalResponseTime = 0;
    this.isHealthy = true;
    this.shouldFail = false;
  }
}

class MockCerebrasProvider extends MockBaseProvider {
  constructor(config = {}) {
    super('cerebras', {
      priority: 1,
      responseDelay: 150,
      ...config,
    });
    this.model = 'llama-4-maverick-17b-128e-instruct';
    this.supportsStreaming = true;
  }

  async generateDreamStream(prompt, options = {}) {
    this.requestCount++;
    const startTime = Date.now();

    if (this.shouldFail || Math.random() < this.failureRate) {
      this.failureCount++;
      throw new Error('Cerebras streaming failure');
    }

    // Simulate streaming response
    const chunks = [
      '{"title": "Streaming',
      ' Cerebras Dream",',
      ' "description": "A dream',
      ' generated via streaming",',
      ' "scenes": [{"type": "environment",',
      ' "description": "Streamed scene",',
      ' "mood": "streaming"}],',
      ' "style": "ethereal"}',
    ];

    let fullResponse = '';
    for (const chunk of chunks) {
      await new Promise((resolve) => setTimeout(resolve, 20));
      fullResponse += chunk;
    }

    this.successCount++;
    const responseTime = Date.now() - startTime;
    this.totalResponseTime += responseTime;

    return fullResponse;
  }

  async batchGenerate(prompts, options = {}) {
    const results = [];

    for (const prompt of prompts) {
      try {
        const result = await this.generateDream(prompt, options);
        results.push(result);
      } catch (error) {
        results.push({
          success: false,
          error: error.message,
          prompt,
        });
      }
    }

    return results;
  }
}

class MockOpenAIProvider extends MockBaseProvider {
  constructor(config = {}) {
    super('openai', {
      priority: 2,
      responseDelay: 200,
      maxTokens: 4000,
      ...config,
    });
    this.model = 'gpt-4';
    this.supportsStreaming = false;
  }

  async generateDream(prompt, options = {}) {
    // OpenAI has token limits, so simulate truncation for very long prompts
    if (prompt.length > 8000) {
      prompt = prompt.substring(0, 8000) + '...';
    }

    const result = await super.generateDream(prompt, options);

    // Modify response to be more OpenAI-like
    result.data.title = `OpenAI ${result.data.title.replace(
      'Mock openai',
      ''
    )}`;
    result.metadata.model = 'gpt-4';
    result.metadata.tokens.total = Math.min(result.metadata.tokens.total, 4000);

    return result;
  }
}

class MockLlamaProvider extends MockBaseProvider {
  constructor(config = {}) {
    super('llama', {
      priority: 3,
      responseDelay: 300,
      ...config,
    });
    this.model = 'llama-2-70b';
    this.isLocal = true;
  }

  async generateDream(prompt, options = {}) {
    const result = await super.generateDream(prompt, options);

    // Modify response to be more Llama-like
    result.data.title = `Local Llama ${result.data.title.replace(
      'Mock llama',
      ''
    )}`;
    result.metadata.model = 'llama-2-70b';
    result.metadata.isLocal = true;

    return result;
  }

  async checkLocalModel() {
    return {
      available: this.isHealthy,
      model: this.model,
      memoryUsage: '8GB',
      gpuUsage: '75%',
    };
  }
}

class MockFailingProvider extends MockBaseProvider {
  constructor(config = {}) {
    super('failing', {
      shouldFail: true,
      failureRate: 1.0,
      ...config,
    });
  }

  async generateDream(prompt, options = {}) {
    this.requestCount++;
    this.failureCount++;
    throw new Error('Mock failing provider always fails');
  }

  async testConnection() {
    throw new Error('Mock failing provider connection failed');
  }
}

class MockSlowProvider extends MockBaseProvider {
  constructor(config = {}) {
    super('slow', {
      responseDelay: 5000, // 5 second delay
      ...config,
    });
  }
}

class MockUnreliableProvider extends MockBaseProvider {
  constructor(config = {}) {
    super('unreliable', {
      failureRate: 0.3, // 30% failure rate
      responseDelay: 100,
      ...config,
    });
  }

  async generateDream(prompt, options = {}) {
    // Simulate intermittent failures
    if (Math.random() < 0.1) {
      // 10% chance of timeout
      await new Promise((resolve) => setTimeout(resolve, 10000));
    }

    return super.generateDream(prompt, options);
  }
}

// Factory function to create mock providers
function createMockProvider(type, config = {}) {
  switch (type) {
    case 'cerebras':
      return new MockCerebrasProvider(config);
    case 'openai':
      return new MockOpenAIProvider(config);
    case 'llama':
      return new MockLlamaProvider(config);
    case 'failing':
      return new MockFailingProvider(config);
    case 'slow':
      return new MockSlowProvider(config);
    case 'unreliable':
      return new MockUnreliableProvider(config);
    default:
      return new MockBaseProvider(type, config);
  }
}

// Mock provider registry for testing
class MockProviderRegistry {
  constructor() {
    this.providers = new Map();
    this.defaultProviders = ['cerebras', 'openai', 'llama'];
  }

  register(name, provider) {
    this.providers.set(name, provider);
  }

  get(name) {
    return this.providers.get(name);
  }

  getAll() {
    return Array.from(this.providers.values());
  }

  getAllNames() {
    return Array.from(this.providers.keys());
  }

  remove(name) {
    return this.providers.delete(name);
  }

  clear() {
    this.providers.clear();
  }

  createDefaultProviders() {
    this.defaultProviders.forEach((type) => {
      const provider = createMockProvider(type);
      this.register(type, provider);
    });
  }

  simulateProviderFailures(providerNames, failureRate = 1.0) {
    providerNames.forEach((name) => {
      const provider = this.get(name);
      if (provider) {
        provider.setFailureRate(failureRate);
      }
    });
  }

  simulateNetworkLatency(delay) {
    this.getAll().forEach((provider) => {
      provider.setResponseDelay(delay);
    });
  }

  resetAllProviders() {
    this.getAll().forEach((provider) => {
      provider.reset();
    });
  }

  getAggregatedMetrics() {
    const allMetrics = this.getAll().map((provider) => provider.getMetrics());

    return {
      totalRequests: allMetrics.reduce((sum, m) => sum + m.totalRequests, 0),
      totalSuccessful: allMetrics.reduce(
        (sum, m) => sum + m.successfulRequests,
        0
      ),
      totalFailed: allMetrics.reduce((sum, m) => sum + m.failedRequests, 0),
      averageResponseTime:
        allMetrics.reduce((sum, m) => sum + m.averageResponseTime, 0) /
        allMetrics.length,
      healthyProviders: allMetrics.filter((m) => m.isHealthy).length,
      totalProviders: allMetrics.length,
    };
  }
}

module.exports = {
  MockBaseProvider,
  MockCerebrasProvider,
  MockOpenAIProvider,
  MockLlamaProvider,
  MockFailingProvider,
  MockSlowProvider,
  MockUnreliableProvider,
  createMockProvider,
  MockProviderRegistry,
};
