// tests/monitoring-integration.test.js
// Integration test for enhanced provider health monitoring and metrics collection

const ProviderManager = require('../providers/ProviderManager');

/**
 * Mock Provider for testing
 */
class MockProvider {
  constructor(name, config = {}) {
    this.name = name;
    this.config = {
      shouldFail: config.shouldFail || false,
      responseTime: config.responseTime || 100,
      failureRate: config.failureRate || 0,
      ...config,
    };
    this.requestCount = 0;
  }

  async generateDream(prompt, options = {}) {
    this.requestCount++;

    // Simulate response time
    await this.sleep(this.config.responseTime);

    // Simulate failures based on failure rate
    if (this.config.shouldFail || Math.random() < this.config.failureRate) {
      throw new Error(`Mock provider ${this.name} failed`);
    }

    return {
      success: true,
      data: {
        id: `dream_${this.requestCount}`,
        title: `Mock Dream ${this.requestCount}`,
        description: `Generated by ${this.name}`,
      },
      tokens: {
        input: prompt.length,
        output: 100,
        total: prompt.length + 100,
      },
    };
  }

  async testConnection() {
    if (this.config.shouldFail) {
      throw new Error(`Mock provider ${this.name} connection failed`);
    }
    return { status: 'healthy' };
  }

  async healthCheck() {
    return this.testConnection();
  }

  sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}

/**
 * Test suite for monitoring integration
 */
async function runMonitoringIntegrationTest() {
  console.log('ðŸ§ª Starting Enhanced Monitoring Integration Test...\n');

  try {
    // Initialize ProviderManager with enhanced monitoring
    const providerManager = new ProviderManager({
      healthCheckInterval: 5000, // 5 seconds for testing
      enableEnhancedMonitoring: true,
      enableAutomatedReporting: true,
    });

    // Initialize enhanced monitoring
    providerManager.initializeEnhancedMonitoring({
      healthMonitor: {
        healthCheckInterval: 5000,
        detailedCheckInterval: 10000,
        alertThresholds: {
          consecutiveFailures: 2,
          responseTimeThreshold: 1000,
          successRateThreshold: 0.7,
          errorRateThreshold: 0.3,
        },
      },
      metricsCollector: {
        collectionInterval: 3000,
        aggregationInterval: 6000,
        enableRealTimeMetrics: true,
      },
      alertingSystem: {
        alertChannels: ['console'],
        alertThresholds: {
          failureRate: 0.2,
          responseTime: 1000,
          consecutiveFailures: 2,
        },
        suppressionRules: {
          duplicateWindow: 10000, // 10 seconds
          maxAlertsPerHour: 5,
        },
      },
    });

    // Create mock providers
    const healthyProvider = new MockProvider('healthy-provider', {
      responseTime: 200,
      failureRate: 0.1, // 10% failure rate
    });

    const slowProvider = new MockProvider('slow-provider', {
      responseTime: 1500, // Slow responses
      failureRate: 0.05,
    });

    const flakyProvider = new MockProvider('flaky-provider', {
      responseTime: 300,
      failureRate: 0.4, // 40% failure rate
    });

    // Register providers
    providerManager.registerProvider('healthy', healthyProvider, {
      priority: 3,
      limits: {
        requestsPerMinute: 60,
        tokensPerMinute: 10000,
        maxConcurrent: 5,
      },
    });

    providerManager.registerProvider('slow', slowProvider, {
      priority: 2,
      limits: {
        requestsPerMinute: 30,
        tokensPerMinute: 5000,
        maxConcurrent: 3,
      },
    });

    providerManager.registerProvider('flaky', flakyProvider, {
      priority: 1,
      limits: {
        requestsPerMinute: 20,
        tokensPerMinute: 3000,
        maxConcurrent: 2,
      },
    });

    console.log('âœ… Providers registered successfully');
    console.log(`   - Healthy Provider (priority: 3, 10% failure rate)`);
    console.log(`   - Slow Provider (priority: 2, 1500ms response time)`);
    console.log(`   - Flaky Provider (priority: 1, 40% failure rate)`);

    // Wait for initial health checks
    console.log('\nâ³ Waiting for initial health checks...');
    await sleep(6000);

    // Test 1: Basic health monitoring
    console.log('\nðŸ“Š Test 1: Basic Health Monitoring');
    const healthReport = providerManager.healthMonitor.getHealthReport();
    console.log(`   Total providers: ${healthReport.summary.total}`);
    console.log(`   Healthy providers: ${healthReport.summary.healthy}`);
    console.log(`   Unhealthy providers: ${healthReport.summary.unhealthy}`);

    // Test 2: Metrics collection
    console.log('\nðŸ“ˆ Test 2: Metrics Collection');
    if (providerManager.metricsCollector) {
      const metricsReport = providerManager.metricsCollector.getMetricsReport();
      console.log(
        `   Total providers in metrics: ${
          Object.keys(metricsReport.providers).length
        }`
      );
    } else {
      console.log(
        '   MetricsCollector not available - using basic metrics only'
      );
      const basicMetrics = providerManager.getProviderMetrics();
      console.log(
        `   Total providers in basic metrics: ${
          Object.keys(basicMetrics).length
        }`
      );
      const totalRequests = Object.values(basicMetrics).reduce(
        (sum, m) => sum + m.requests,
        0
      );
      console.log(`   Summary - Total requests: ${totalRequests}`);
    }

    // Test 3: Generate some requests to collect metrics
    console.log('\nðŸ”„ Test 3: Generating Requests for Metrics Collection');
    const testPromises = [];

    for (let i = 0; i < 20; i++) {
      testPromises.push(
        providerManager
          .executeWithFallback(
            async (provider, providerName) => {
              return await provider.generateDream(`Test dream ${i}`, {
                model: 'test-model',
                temperature: 0.7,
                maxTokens: 100,
                operationType: 'generateDream',
                metadata: { testRun: true, requestIndex: i },
              });
            },
            null,
            {
              timeout: 5000,
              maxAttempts: 2,
            }
          )
          .catch((error) => {
            // Ignore errors for testing purposes
            return { error: error.message };
          })
      );

      // Add some delay between requests
      if (i % 5 === 0) {
        await sleep(500);
      }
    }

    const results = await Promise.allSettled(testPromises);
    const successful = results.filter(
      (r) => r.status === 'fulfilled' && !r.value.error
    ).length;
    const failed = results.length - successful;

    console.log(`   Generated ${results.length} requests`);
    console.log(`   Successful: ${successful}, Failed: ${failed}`);

    // Wait for metrics aggregation
    console.log('\nâ³ Waiting for metrics aggregation...');
    await sleep(8000);

    // Test 4: Updated metrics report
    console.log('\nðŸ“Š Test 4: Updated Metrics Report');
    let updatedMetrics = null;
    if (providerManager.metricsCollector) {
      updatedMetrics = providerManager.metricsCollector.getMetricsReport(null, {
        timeRange: '10m',
        includeRealtime: true,
        includeBaseline: true,
      });
    } else {
      // Use basic metrics as fallback
      const basicMetrics = providerManager.getProviderMetrics();
      updatedMetrics = {
        summary: {
          totalRequests: Object.values(basicMetrics).reduce(
            (sum, m) => sum + m.requests,
            0
          ),
          totalSuccesses: Object.values(basicMetrics).reduce(
            (sum, m) => sum + m.successes,
            0
          ),
          totalFailures: Object.values(basicMetrics).reduce(
            (sum, m) => sum + m.failures,
            0
          ),
          avgSuccessRate:
            Object.values(basicMetrics).reduce(
              (sum, m) => sum + m.successRate,
              0
            ) / Object.keys(basicMetrics).length,
          avgResponseTime:
            Object.values(basicMetrics).reduce(
              (sum, m) => sum + m.avgResponseTime,
              0
            ) / Object.keys(basicMetrics).length,
        },
        providers: basicMetrics,
      };
    }

    console.log(`   Summary after test requests:`);
    console.log(
      `   - Total requests: ${updatedMetrics.summary.totalRequests || 0}`
    );
    console.log(
      `   - Total successes: ${updatedMetrics.summary.totalSuccesses || 0}`
    );
    console.log(
      `   - Total failures: ${updatedMetrics.summary.totalFailures || 0}`
    );
    console.log(
      `   - Average success rate: ${(
        (updatedMetrics.summary.avgSuccessRate || 0) * 100
      ).toFixed(1)}%`
    );
    console.log(
      `   - Average response time: ${(
        updatedMetrics.summary.avgResponseTime || 0
      ).toFixed(0)}ms`
    );

    // Show per-provider metrics
    console.log('\n   Per-provider metrics:');
    for (const [providerName, providerData] of Object.entries(
      updatedMetrics.providers
    )) {
      if (providerData.aggregated) {
        console.log(`   - ${providerName}:`);
        console.log(`     * Requests: ${providerData.aggregated.requests}`);
        console.log(
          `     * Success rate: ${(
            providerData.aggregated.successRate * 100
          ).toFixed(1)}%`
        );
        console.log(
          `     * Avg response time: ${providerData.aggregated.avgResponseTime.toFixed(
            0
          )}ms`
        );
        console.log(
          `     * Health score: ${providerData.aggregated.healthScore}`
        );

        if (providerData.realtime) {
          console.log(
            `     * Active requests: ${providerData.realtime.activeRequests}`
          );
          console.log(
            `     * Requests in last minute: ${providerData.realtime.requestsInLastMinute}`
          );
        }
      } else if (providerData.requests !== undefined) {
        // Basic metrics fallback
        console.log(`   - ${providerName}:`);
        console.log(`     * Requests: ${providerData.requests}`);
        console.log(
          `     * Success rate: ${(providerData.successRate * 100).toFixed(1)}%`
        );
        console.log(
          `     * Avg response time: ${providerData.avgResponseTime.toFixed(
            0
          )}ms`
        );
        console.log(
          `     * Consecutive failures: ${providerData.consecutiveFailures}`
        );
      }
    }

    // Test 5: Alert statistics
    console.log('\nðŸš¨ Test 5: Alert Statistics');
    const alertStats = providerManager.alertingSystem.getAlertStatistics({
      timeRange: '10m',
    });

    console.log(`   Total alerts in last 10 minutes: ${alertStats.total}`);
    console.log(`   Alerts by severity:`, alertStats.bySeverity);
    console.log(`   Alerts by type:`, alertStats.byType);
    console.log(`   Alerts by provider:`, alertStats.byProvider);

    // Test 6: Comprehensive monitoring report
    console.log('\nðŸ“‹ Test 6: Comprehensive Monitoring Report');
    const monitoringReport = providerManager.getMonitoringReport({
      timeRange: '10m',
      includeRealtime: true,
      includeBaseline: true,
    });

    console.log(`   Report timestamp: ${monitoringReport.timestamp}`);
    console.log(
      `   Available providers: ${monitoringReport.basic.availableProviders}/${monitoringReport.basic.totalProviders}`
    );

    if (monitoringReport.health) {
      console.log(
        `   Overall health: ${monitoringReport.health.summary.healthy}/${monitoringReport.health.summary.total} healthy`
      );
    }

    // Test 7: System health status
    console.log('\nðŸ¥ Test 7: System Health Status');
    const systemHealth = providerManager.getSystemHealthStatus();
    console.log(`   Overall status: ${systemHealth.status}`);
    console.log(`   Health score: ${systemHealth.score}/100`);
    console.log(
      `   Available providers: ${systemHealth.availableProviders}/${systemHealth.totalProviders}`
    );

    // Test 8: Export monitoring data
    console.log('\nðŸ’¾ Test 8: Export Monitoring Data');
    const exportedData = providerManager.exportMonitoringData({
      timeRange: '10m',
      format: 'json',
    });

    console.log(`   Export timestamp: ${exportedData.timestamp}`);
    console.log(`   Export format: ${exportedData.format}`);
    console.log(`   Time range: ${exportedData.timeRange}`);
    console.log(
      `   Exported providers: ${
        Object.keys(exportedData.data.providers).length
      }`
    );

    // Test 9: Simulate provider failure and recovery
    console.log('\nðŸ”§ Test 9: Simulating Provider Failure and Recovery');

    // Make flaky provider always fail
    flakyProvider.config.shouldFail = true;
    console.log('   Set flaky provider to always fail');

    // Wait for health checks to detect the failure
    await sleep(8000);

    const failureHealthReport = providerManager.healthMonitor.getHealthReport();
    console.log(
      `   Health after failure: ${failureHealthReport.summary.healthy}/${failureHealthReport.summary.total} healthy`
    );

    // Recover the provider
    flakyProvider.config.shouldFail = false;
    console.log('   Recovered flaky provider');

    // Wait for recovery detection
    await sleep(8000);

    const recoveryHealthReport =
      providerManager.healthMonitor.getHealthReport();
    console.log(
      `   Health after recovery: ${recoveryHealthReport.summary.healthy}/${recoveryHealthReport.summary.total} healthy`
    );

    // Final summary
    console.log('\nðŸŽ‰ Test Summary');
    let finalMetrics = null;
    if (providerManager.metricsCollector) {
      finalMetrics = providerManager.metricsCollector.getMetricsReport();
    } else {
      const basicMetrics = providerManager.getProviderMetrics();
      finalMetrics = {
        summary: {
          totalRequests: Object.values(basicMetrics).reduce(
            (sum, m) => sum + m.requests,
            0
          ),
          avgSuccessRate:
            Object.values(basicMetrics).reduce(
              (sum, m) => sum + m.successRate,
              0
            ) / Object.keys(basicMetrics).length,
        },
      };
    }

    let finalAlerts = null;
    if (providerManager.alertingSystem) {
      finalAlerts = providerManager.alertingSystem.getAlertStatistics({
        timeRange: '15m',
      });
    } else {
      finalAlerts = { total: 0 };
    }
    const finalHealth = providerManager.getSystemHealthStatus();

    console.log(
      `   Final system health: ${finalHealth.status} (${finalHealth.score}/100)`
    );
    console.log(
      `   Total requests processed: ${finalMetrics.summary.totalRequests}`
    );
    console.log(
      `   Overall success rate: ${(
        finalMetrics.summary.avgSuccessRate * 100
      ).toFixed(1)}%`
    );
    console.log(`   Total alerts generated: ${finalAlerts.total}`);
    console.log(`   Test duration: ~2 minutes`);

    // Cleanup
    console.log('\nðŸ§¹ Cleaning up...');
    providerManager.destroy();

    console.log(
      '\nâœ… Enhanced Monitoring Integration Test completed successfully!'
    );
    return true;
  } catch (error) {
    console.error('\nâŒ Test failed:', error.message);
    console.error(error.stack);
    return false;
  }
}

/**
 * Sleep utility
 */
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// Run the test if this file is executed directly
if (require.main === module) {
  runMonitoringIntegrationTest()
    .then((success) => {
      process.exit(success ? 0 : 1);
    })
    .catch((error) => {
      console.error('Test execution failed:', error);
      process.exit(1);
    });
}

module.exports = {
  runMonitoringIntegrationTest,
  MockProvider,
};
